import os

from Crypto.Signature import PKCS1_v1_5
from Crypto.Hash import SHA
from Crypto.PublicKey import RSA


# This function will use the private key to sign the files stored in the pastebot.net
# This function will be called in the function file_to_sign()
def sign_file(f):
    # TODO: For Part 2, you'll use public key crypto here
    # The existing scheme just ensures the updates start with the line 'Caesar'
    # This is naive -- replace it with something better!
    # return bytes("Caesar\n", "ascii") + f
    
    # Import the private key from the root folder of Master
    # If the key does not exist in the root folder of Master, the program will exit
    # Master should generate the key with command "generate_key" before calling this function
    key = RSA.importKey(open('mykeyprivate.pem').read())
    # Hash the file with SHA
    hash = SHA.new(f)
    signer = PKCS1_v1_5.new(key)
    # Get the signature generated by PKCS1_V1_5
    signature = signer.sign(hash)
    # Put the signature before the file
    # Put the message "Message_Start_Here" after the signature before the original file
    # This message will become the flag to split the signature and the original file
    f_signed = signature + bytes("\nMessage_Start_Here\n", "ascii") + f
    return f_signed


# This function is designed to get the name of the file that is to be signed by the Master
def file_to_sign():
    fn = input("Which file in pastebot.net should be signed? ")
    # The file should be in pastebot.net, if not, the program will stop
    if not os.path.exists(os.path.join("../pastebot.net", fn)):
        print("The given file doesn't exist on pastebot.net")
        os.exit(1)
    # Read the file into memory
    f = open(os.path.join("../pastebot.net", fn), "rb").read()
    # Call sign_file(f) to sign the file
    signed_f = sign_file(f)
    # Write the signed file to the pastebot.net
    signed_fn = os.path.join("../pastebot.net", fn + ".signed")
    out = open(signed_fn, "wb")
    out.write(signed_f)
    out.close()
    print("Signed file written to", signed_fn)


# Master should have the private key before signing the files
# This function is designed to generate the RSA public key and private key
def generate_key():
    # Generate the key with 2048 bits
    key = RSA.generate(2048)
    f = open('mykeyprivate.pem', 'wb')
    # Write the private key to the root folder of Master
    f.write(key.exportKey('PEM'))
    f.close()

    pubkey = key.publickey()
    fv = open('../pastebot.net/mykeypublic.pem', 'wb')
    # Write the public key to pastebot.net, so that all of the bots can get it
    fv.write(pubkey.exportKey('PEM'))
    fv.close()

    print("Private key is stored in the root folder, public key is stored in pastebot.net")


if __name__ == "__main__":

    while 1:
        # When Master run this program, the following three commands will be printed on the console
        print("Three commands available:generate_key, sign, exit")
        raw_cmd = input("Enter command: ")
        cmd = raw_cmd.split()
        if not cmd:
            print("You need to enter a command...")
            continue
        # Master should use command "generate_key" to generate the private key and public key
        if cmd[0].lower() == "generate_key":
            generate_key()
        # Master should use command "signy" to sign the file in the pastebot.net
        elif cmd[0].lower() == "sign":
            file_to_sign()
        # Master can also use command "exit" to stop this program
        elif cmd[0].lower() == "quit" or cmd[0].lower() == "exit":
            break


